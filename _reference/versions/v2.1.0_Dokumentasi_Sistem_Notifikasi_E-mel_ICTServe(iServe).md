# Dokumentasi Sistem Notifikasi E-mel ICTServe (iServe) v2.1.0

| Atribut              | Nilai                                               |
| -------------------- | --------------------------------------------------- |
| **Versi Dokumen**    | 3.0.0                                               |
| **Tarikh Kemaskini** | 6 Oktober 2025                                      |
| **Status**           | Aktif                                               |
| **Klasifikasi**      | Dokumentasi Teknikal Dalaman                        |
| **Penulis**          | Pasukan Pembangunan ICTServe                        |
| **Sasaran Audiens**  | Pembangun Sistem, Pentadbir Sistem, Jurutera DevOps |

## Kandungan

- [Pengenalan](#pengenalan)
- [Panduan Pantas / Quick Start](#panduan-pantas--quick-start)
- [Glosari](#glosari)
- [Seni Bina Sistem Notifikasi](#seni-bina-sistem-notifikasi)
- [Implementasi Teknikal](#implementasi-teknikal)
- [Konfigurasi dan Tetapan](#konfigurasi-dan-tetapan)
- [Jenis Notifikasi](#jenis-notifikasi)
- [Templat E-mel](#templat-e-mel)
- [Pengurusan Barisan (Queue)](#pengurusan-barisan-queue)
- [Prestasi dan Pengoptimuman](#prestasi-dan-pengoptimuman)
- [Ujian dan Penyahpepijatan](#ujian-dan-penyahpepijatan)
- [Pemantauan dan Metrik](#pemantauan-dan-metrik)
- [Pengendalian Ralat](#pengendalian-ralat)
- [Keselamatan](#keselamatan)
- [Panduan Penyelesaian Masalah](#panduan-penyelesaian-masalah)
- [Best Practices](#best-practices)
- [Sejarah Revisi](#sejarah-revisi)
- [Sokongan dan Bantuan](#sokongan-dan-bantuan)

## Pengenalan

### Tujuan Dokumen

Dokumen ini menyediakan panduan komprehensif untuk sistem notifikasi e-mel dalam ICTServe (iServe).
Ia merangkumi implementasi teknikal, konfigurasi, pengurusan templat, dan strategi pengoptimuman.
Matlamatnya adalah untuk memastikan penyampaian notifikasi yang boleh dipercayai dan cekap.

### Skop Sistem

Sistem notifikasi e-mel ICTServe menguruskan:

- **Notifikasi Transaksional**: Pengesahan, kelulusan, penolakan
- **Notifikasi Operasional**: Peringatan, amaran, status updates
- **Notifikasi Administratif**: Laporan sistem, audit alerts
- **Notifikasi Marketing**: Pengumuman, newsletter (pilihan)

### Objektif Utama

| Objektif                | Penerangan                                     | Metrik Sasaran                      |
| ----------------------- | ---------------------------------------------- | ----------------------------------- |
| **Kebolehpercayaan**    | Memastikan notifikasi sampai kepada penerima   | 99.5% delivery rate                 |
| **Prestasi**            | Masa pemprosesan dan penghantaran yang optimum | < 30 saat untuk notifikasi kritikal |
| **Skalabiliti**         | Mengendalikan volume tinggi notifikasi         | 10,000+ e-mel/jam                   |
| **Kebolehselenggaraan** | Mudah dikonfigurasi dan diselenggara           | < 2 jam downtime/bulan              |

## Seni Bina Sistem Notifikasi {#seni-bina-sistem-notifikasi}

## Panduan Pantas / Quick Start {#panduan-pantas--quick-start}

Berikut adalah langkah-langkah ringkas untuk menjalankan sistem notifikasi di persekitaran
pembangunan (local) atau staging. Tujuannya adalah supaya pembangun baru dan pentadbir dapat
memulakan dengan cepat.

1. Pasang kebergantungan projek:

```bash
composer install
npm install
```

1. Salin dan kemaskini `.env`:

```bash
cp .env.example .env
php artisan key:generate
```

Isi pembolehubah penting dalam `.env` (lihat bahagian "Environment Variables").
Pastikan `QUEUE_CONNECTION` dan konfigurasi `MAIL_` adalah betul.

1. Jalankan migrasi dan seed (staging/dev):

```bash
php artisan migrate --seed
```

1. Mulakan worker queue untuk development:

```bash
php artisan queue:work --queue=notifications,high-priority,default --sleep=3 --tries=3
```

1. Hantar e-mel ujian (contoh):

```bash
php artisan tinker
>>> Mail::raw('Test email', function($msg){ $msg->to('you@motac.gov.my')->subject('Test'); });
```

1. Jika menggunakan Redis, pastikan server Redis berjalan dan konfigurasi sambungan di
   `config/database.php` dan `config/queue.php` adalah betul.

## Glosari {#glosari}

Berikut adalah istilah dan akronim yang digunakan dalam dokumentasi ini:

- BPM: Bahagian Pengurusan (organisasi dalaman) â€” contohnya tempat pengambilan peralatan.
- iServe / ICTServe: Nama sistem dalaman untuk pengurusan perkhidmatan ICT.
- Queue Worker: Proses yang memproses jobs dari queue (contoh: `php artisan queue:work`).
- Idempotency: Sifat operasi yang memastikan pengulangan tidak menghasilkan kesan berganda.
- Notification Channel: Saluran penghantaran notifikasi (mail, sms, database, push).
- Dead Letter Queue (DLQ): Queue untuk job yang gagal selepas beberapa percubaan.

### Gambaran Keseluruhan Seni Bina {#gambaran-keseluruhan-seni-bina}

`````mermaid
graph TB
    subgraph "Application Layer"
        App[ICTServe Application]
        Events[Event Listeners]
        Jobs[Notification Jobs]
    end

    subgraph "Notification System"
        Manager[Notification Manager]
        Templates[Template Engine]
        Queue[Queue System]
        Channels[Notification Channels]
    end

    subgraph "External Services"
        SMTP[SMTP Server]
        SMS[SMS Gateway]
        Push[Push Notification Service]
    end

    subgraph "Storage & Logging"
        DB[(Database)]
        Redis[(Redis Cache)]
        Logs[Log Storage]
    end

    App --> Events
    Events --> Manager
    Manager --> Templates
    Manager --> Queue
    Queue --> Jobs
    Jobs --> Channels
    Channels --> SMTP
    Channels --> SMS
    Channels --> Push

    Manager --> DB
    Queue --> Redis
    Channels --> Logs

    classDef app fill:#e1f5fe
    classDef notification fill:#f3e5f5
    classDef external fill:#fff3e0
    classDef storage fill:#e8f5e8

    class App,Events,Jobs app
    class Manager,Templates,Queue,Channels notification
    class SMTP,SMS,Push external
    class DB,Redis,Logs storage

### Sequence Diagram (Notifikasi Lifecycle)

````mermaid
sequenceDiagram
    participant U as User
    participant A as Application
    participant E as Event Listener
    participant Q as Queue
    participant W as Worker / Job
    participant M as Mail Server (SMTP)

    U->>A: Trigger action (e.g., approve loan)
    A->>E: Dispatch Notification Event
    E->>Q: Push Notification Job to queue
    Q->>W: Worker picks up job
    W->>M: Send email via SMTP
    W->>A: Persist database notification
    W->>Log: Emit NotificationSent event

### Komponen Utama

| Komponen | Tujuan | Teknologi |
|----------|--------|-----------|
| **Notification Manager** | Orchestration dan routing notifikasi | Laravel Notifications |
| **Template Engine** | Rendering templat e-mel dinamik | Blade Templates, Markdown |
| **Queue System** | Pemprosesan asinkron notifikasi | Redis, Database |
| **Channel Handlers** | Interface dengan penyedia e-mel | SMTP, API integrations |
| **Event Listeners** | Trigger automatik notifikasi | Laravel Events |

## Implementasi Teknikal {#implementasi-teknikal}

### Struktur Kelas Notifikasi

```php
<?php

namespace App\Notifications;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Notifications\Messages\MailMessage;
use Illuminate\Notifications\Notification;
use Illuminate\Queue\SerializesModels;
use App\Models\User;
use App\Models\LoanApplication;

class LoanApplicationApproved extends Notification implements ShouldQueue
{
    use Queueable, SerializesModels;

    protected $loanApplication;
    protected $approver;
    protected $metadata;

    /**
     * Cipta instance notifikasi baru
     */
    public function __construct(LoanApplication $loanApplication, User $approver = null, array $metadata = [])
    {
        $this->loanApplication = $loanApplication;
        $this->approver = $approver;
        $this->metadata = $metadata;

        // Set queue dan delay jika perlu
        $this->onQueue('notifications');

        // Set priority berdasarkan jenis notifikasi
        if ($this->isUrgent()) {
            $this->onQueue('high-priority');
        }
    }

    /**
     * Tentukan saluran penghantaran
     */
    public function via($notifiable): array
    {
        $channels = ['mail', 'database'];

        // Tambah SMS untuk notifikasi kritikal
        if ($this->isUrgent() && $notifiable->mobile_number) {
            $channels[] = 'sms';
        }

        // Periksa preferences pengguna
        if ($notifiable->notification_preferences) {
            return array_intersect($channels, $notifiable->notification_preferences);
        }

        return $channels;
    }

    /**
     * Bina kandungan e-mel
     */
    public function toMail($notifiable): MailMessage
    {
        return (new MailMessage)
            ->subject($this->getSubject())
            ->markdown('emails.loan-application-approved', [
                'user' => $notifiable,
                'application' => $this->loanApplication,
                'approver' => $this->approver,
                'metadata' => $this->metadata,
                'actionUrl' => $this->getActionUrl(),
            ])
            ->tag('loan-approval')
            ->metadata('application_id', $this->loanApplication->id)
            ->metadata('user_id', $notifiable->id);
    }

    /**
     * Data untuk notifikasi database
     */
    public function toDatabase($notifiable): array
    {
        return [
            'type' => 'loan_application_approved',
            'title' => $this->getSubject(),
            'message' => $this->getShortMessage(),
            'application_id' => $this->loanApplication->id,
            'approver_name' => $this->approver?->name,
            'action_url' => $this->getActionUrl(),
            'metadata' => $this->metadata,
        ];
    }

    /**
     * Periksa jika notifikasi adalah mendesak
     */
    protected function isUrgent(): bool
    {
        return in_array($this->loanApplication->priority, ['high', 'urgent']);
    }

    /**
     * Dapatkan subjek e-mel
     */
    protected function getSubject(): string
    {
        return sprintf(
            '[ICTServe] Permohonan Pinjaman %s - Diluluskan',
            $this->loanApplication->application_number
        );
    }

    /**
     * Dapatkan mesej ringkas
     */
    protected function getShortMessage(): string
    {
        return sprintf(
            'Permohonan pinjaman %s telah diluluskan oleh %s',
            $this->loanApplication->application_number,
            $this->approver?->name ?? 'sistem'
        );
    }

    /**
     * URL tindakan untuk e-mel
     */
    protected function getActionUrl(): string
    {
        return route('loan-applications.show', $this->loanApplication);
    }
}
`````

### Notification Manager

```php
<?php

namespace App\Services;

use App\Models\User;
use Illuminate\Support\Facades\Notification;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Cache;

class NotificationService
{
    protected $rateLimitKey = 'notification_rate_limit:';
    protected $maxNotificationsPerHour = 100;

    /**
     * Hantar notifikasi dengan rate limiting
     */
    public function send($notifiable, $notification): void
    {
        try {
            // Periksa rate limiting
            if ($this->isRateLimited($notifiable)) {
                Log::warning('Notification rate limit exceeded', [
                    'user_id' => $notifiable->id ?? null,
                    'notification' => get_class($notification)
                ]);
                return;
            }

            // Periksa user preferences
            if (!$this->shouldSendNotification($notifiable, $notification)) {
                Log::info('Notification skipped due to user preferences', [
                    'user_id' => $notifiable->id ?? null,
                    'notification' => get_class($notification)
                ]);
                return;
            }

            // Hantar notifikasi
            $notifiable->notify($notification);

            // Update rate limiting counter
            $this->updateRateLimit($notifiable);

            // Log successful notification
            Log::info('Notification sent successfully', [
                'user_id' => $notifiable->id ?? null,
                'notification' => get_class($notification),
                'channels' => $notification->via($notifiable)
            ]);

        } catch (\Exception $e) {
            Log::error('Failed to send notification', [
                'user_id' => $notifiable->id ?? null,
                'notification' => get_class($notification),
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);

            // Optionally queue for retry
            $this->queueForRetry($notifiable, $notification, $e);
        }
    }

    /**
     * Hantar notifikasi kepada multiple users
     */
    public function sendToMultiple($users, $notification): void
    {
        // Chunk users untuk mengelakkan memory issues
        collect($users)->chunk(100)->each(function ($userChunk) use ($notification) {
            Notification::send($userChunk, $notification);
        });
    }

    /**
     * Hantar notifikasi berdasarkan role
     */
    public function sendToRole(string $role, $notification): void
    {
        $users = User::role($role)->where('status', 'active')->get();
        $this->sendToMultiple($users, $notification);
    }

    /**
     * Periksa rate limiting
     */
    protected function isRateLimited($notifiable): bool
    {
        if (!$notifiable->id) {
            return false;
        }

        $key = $this->rateLimitKey . $notifiable->id;
        $count = Cache::get($key, 0);

        return $count >= $this->maxNotificationsPerHour;
    }

    /**
     * Update rate limiting counter
     */
    protected function updateRateLimit($notifiable): void
    {
        if (!$notifiable->id) {
            return;
        }

        $key = $this->rateLimitKey . $notifiable->id;
        Cache::increment($key, 1);
        Cache::expire($key, 3600); // 1 hour
    }

    /**
     * Periksa jika notifikasi patut dihantar
     */
    protected function shouldSendNotification($notifiable, $notification): bool
    {
        // Periksa jika user aktif
        if (method_exists($notifiable, 'isActive') && !$notifiable->isActive()) {
            return false;
        }

        // Periksa notification preferences
        if (method_exists($notifiable, 'canReceiveNotification')) {
            return $notifiable->canReceiveNotification(get_class($notification));
        }

        return true;
    }

    /**
     * Queue notifikasi untuk retry
     */
    protected function queueForRetry($notifiable, $notification, \Exception $exception): void
    {
        // Implement retry logic jika diperlukan
        // Contoh: dispatch ke failed notification queue
    }
}
```

## Konfigurasi dan Tetapan

### Konfigurasi E-mel

```php
<?php
// config/mail.php

return [
    'default' => env('MAIL_MAILER', 'smtp'),

    'mailers' => [
        'smtp' => [
            'transport' => 'smtp',
            'host' => env('MAIL_HOST', 'smtp.motac.gov.my'),
            'port' => env('MAIL_PORT', 587),
            'encryption' => env('MAIL_ENCRYPTION', 'tls'),
            'username' => env('MAIL_USERNAME'),
            'password' => env('MAIL_PASSWORD'),
            'timeout' => 60,
            'local_domain' => env('MAIL_EHLO_DOMAIN'),
        ],

        'ses' => [
            'transport' => 'ses',
            'region' => env('AWS_DEFAULT_REGION', 'ap-southeast-1'),
        ],

        'log' => [
            'transport' => 'log',
            'channel' => env('MAIL_LOG_CHANNEL'),
        ],

        'array' => [
            'transport' => 'array',
        ],

        'failover' => [
            'transport' => 'failover',
            'mailers' => [
                'smtp',
                'log',
            ],
        ],
    ],

    'from' => [
        'address' => env('MAIL_FROM_ADDRESS', 'noreply@motac.gov.my'),
        'name' => env('MAIL_FROM_NAME', 'ICTServe MOTAC'),
    ],

    'reply_to' => [
        'address' => env('MAIL_REPLY_TO_ADDRESS', 'support@motac.gov.my'),
        'name' => env('MAIL_REPLY_TO_NAME', 'ICTServe Support'),
    ],
];
```

### Konfigurasi Queue

```php
<?php
// config/queue.php

return [
    'default' => env('QUEUE_CONNECTION', 'redis'),

    'connections' => [
        'redis' => [
            'driver' => 'redis',
            'connection' => 'default',
            'queue' => env('REDIS_QUEUE', 'default'),
            'retry_after' => 90,
            'block_for' => null,
            'after_commit' => false,
        ],

        'notifications' => [
            'driver' => 'redis',
            'connection' => 'default',
            'queue' => 'notifications',
            'retry_after' => 90,
        ],

        'high-priority' => [
            'driver' => 'redis',
            'connection' => 'default',
            'queue' => 'high-priority',
            'retry_after' => 60,
        ],
    ],

    'batching' => [
        'database' => env('DB_CONNECTION', 'mysql'),
        'table' => 'job_batches',
    ],

    'failed' => [
        'driver' => env('QUEUE_FAILED_DRIVER', 'database'),
        'database' => env('DB_CONNECTION', 'mysql'),
        'table' => 'failed_jobs',
    ],
];
```

### Environment Variables

```bash
# .env (Edit the following values to match your environment)
MAIL_MAILER=smtp
MAIL_HOST=smtp.motac.gov.my         # <-- Set your SMTP server host
MAIL_PORT=587                      # <-- Set your SMTP port
MAIL_USERNAME=ictserve@motac.gov.my # <-- Set your SMTP username
MAIL_PASSWORD=secure_password      # <-- Set your SMTP password
MAIL_ENCRYPTION=tls                # <-- Set encryption (tls or ssl)
MAIL_FROM_ADDRESS=noreply@motac.gov.my # <-- Set the sender email address
MAIL_FROM_NAME="ICTServe MOTAC"        # <-- Set the sender name

# Queue Configuration
QUEUE_CONNECTION=redis             # <-- Set your queue connection (redis, database, etc)
REDIS_QUEUE=default                # <-- Set your Redis queue name

# Rate Limiting
NOTIFICATION_RATE_LIMIT=100        # <-- Max notifications per hour
NOTIFICATION_RETRY_ATTEMPTS=3      # <-- Number of retry attempts
NOTIFICATION_RETRY_DELAY=300       # <-- Delay between retries (seconds)

# Monitoring
MAIL_LOG_CHANNEL=mail              # <-- Log channel for mail
NOTIFICATION_MONITORING=true       # <-- Enable notification monitoring
```

## Jenis Notifikasi

### Klasifikasi Notifikasi

| Kategori          | Jenis      | Keutamaan | Saluran             | Contoh               |
| ----------------- | ---------- | --------- | ------------------- | -------------------- |
| **Transaksional** | Pengesahan | High      | Mail, Database      | Permohonan dihantar  |
| **Transaksional** | Kelulusan  | High      | Mail, Database, SMS | Pinjaman diluluskan  |
| **Operasional**   | Peringatan | Medium    | Mail, Database      | Tarikh pulang hampir |
| **Operasional**   | Amaran     | High      | Mail, SMS           | Pinjaman lewat       |
| **Sistem**        | Status     | Low       | Database            | Sistem maintenance   |
| **Administratif** | Laporan    | Medium    | Mail                | Laporan harian       |

### Implementasi Notifikasi Utama

#### 1. Notifikasi Pinjaman Peralatan

```php
<?php
// Permohonan Baharu
class LoanApplicationSubmitted extends Notification
{
    // Implementation untuk pemohon dan approver
}
```

```php
<?php
// config/mail.php (Edit env() values to match your environment)

return [
    'default' => env('MAIL_MAILER', 'smtp'),

    'mailers' => [
        'smtp' => [
            'transport' => 'smtp',
            'host' => env('MAIL_HOST', 'smtp.motac.gov.my'), // <-- Set your SMTP server host
            'port' => env('MAIL_PORT', 587),                 // <-- Set your SMTP port
            'encryption' => env('MAIL_ENCRYPTION', 'tls'),   // <-- Set encryption (tls or ssl)
            'username' => env('MAIL_USERNAME'),              // <-- Set your SMTP username
            'password' => env('MAIL_PASSWORD'),              // <-- Set your SMTP password
            'timeout' => 60,
            'local_domain' => env('MAIL_EHLO_DOMAIN'),
        ],

        'ses' => [
            'transport' => 'ses',
            'region' => env('AWS_DEFAULT_REGION', 'ap-southeast-1'), // <-- Set your AWS region
        ],

        'log' => [
            'transport' => 'log',
            'channel' => env('MAIL_LOG_CHANNEL'), // <-- Set your log channel
        ],

        'array' => [
            'transport' => 'array',
        ],

        'failover' => [
            'transport' => 'failover',
            'mailers' => [
                'smtp',
                'log',
            ],
        ],
    ],

    'from' => [
        'address' => env('MAIL_FROM_ADDRESS', 'noreply@motac.gov.my'), // <-- Set sender email address
        'name' => env('MAIL_FROM_NAME', 'ICTServe MOTAC'),             // <-- Set sender name
    ],

    'reply_to' => [
        'address' => env('MAIL_REPLY_TO_ADDRESS', 'support@motac.gov.my'), // <-- Set reply-to email address
        'name' => env('MAIL_REPLY_TO_NAME', 'ICTServe Support'),           // <-- Set reply-to name
    ],
];
```

// Tiket diselesaikan
class HelpdeskTicketResolved extends Notification
{
// Implementation dengan solution details
}

`````

## Templat E-mel {#templat-e-mel}

### Struktur Templat

````blade
{{-- resources/views/emails/loan-application-approved.blade.php --}}
@component('mail::message')

# Permohonan Pinjaman Diluluskan

Tahniah! Permohonan pinjaman ICT anda telah diluluskan.

## Butiran Permohonan

@component('mail::panel')
**Nombor Permohonan:** {{ $application->application_number }}
**Tarikh Permohonan:** {{ $application->created_at->format('d/m/Y') }}
**Tempoh Pinjaman:** {{ $application->loan_start_date->format('d/m/Y') }} - {{ $application->loan_end_date->format('d/m/Y') }}
**Diluluskan oleh:** {{ $approver->name ?? 'Sistem' }}
@endcomponent

## Peralatan yang Diluluskan

@component('mail::table')
| Jenis Peralatan | Kuantiti Dimohon | Kuantiti Diluluskan |
|:----------------|:----------------:|:------------------:|
@foreach($application->items as $item)
| {{ $item->equipment_type }} | {{ $item->quantity_requested }} | {{ $item->quantity_approved }} |
@endforeach
@endcomponent

## Langkah Seterusnya

1. **Tunggu Notifikasi**: Anda akan menerima notifikasi apabila peralatan sedia untuk diambil
2. **Sediakan Dokumen**: Pastikan anda membawa kad pengenalan untuk pengesahan
3. **Lokasi Pengambilan**: Pejabat BPM, Aras 3, Blok A

@component('mail::button', ['url' => $actionUrl, 'color' => 'primary'])
Lihat Butiran Permohonan
@endcomponent

## Maklumat Hubungan

Jika anda mempunyai sebarang pertanyaan, sila hubungi:
- **E-mel:** bpm@motac.gov.my
- **Telefon:** 03-8000 8000 (sambungan 1234)

---

**Nota Penting:** E-mel ini dijana secara automatik. Sila jangan membalas e-mel ini.

{{ config('app.name') }}
@endcomponent
`````

### Templat Responsif

```blade
{{-- resources/views/emails/components/header.blade.php --}}
<table width="100%" cellpadding="0" cellspacing="0" role="presentation">
    <tr>
        <td align="center" style="padding: 20px 0;">
            <img src="{{ asset('images/motac-logo.png') }}" alt="MOTAC Logo"
                 width="120" height="60" style="max-width: 120px;">
        </td>
    </tr>
    <tr>
        <td align="center" style="background-color: #1e40af; color: white; padding: 15px;">
            <h1 style="margin: 0; font-size: 24px; font-weight: bold;">
                {{ $title ?? 'ICTServe Notification' }}
            </h1>
        </td>
    </tr>
</table>
```

### Templat Multilingual

```php
<?php
// resources/lang/ms/notifications.php
// (example language file contents omitted for brevity)
```

```php
<?php
// config/queue.php (Edit env() values to match your environment)

return [
    'default' => env('QUEUE_CONNECTION', 'redis'), // <-- Set your default queue connection

    'connections' => [
        'redis' => [
            'driver' => 'redis',
            'connection' => 'default',
            'queue' => env('REDIS_QUEUE', 'default'), // <-- Set your Redis queue name
            'retry_after' => 90,
            'block_for' => null,
            'after_commit' => false,
        ],

        'notifications' => [
            'driver' => 'redis',
            'connection' => 'default',
            'queue' => 'notifications', // <-- Set notifications queue name
            'retry_after' => 90,
        ],

        'high-priority' => [
            'driver' => 'redis',
            'connection' => 'default',
            'queue' => 'high-priority', // <-- Set high-priority queue name
            'retry_after' => 60,
        ],
    ],

    'batching' => [
        'database' => env('DB_CONNECTION', 'mysql'), // <-- Set your database connection
        'table' => 'job_batches',
    ],

    'failed' => [
        'driver' => env('QUEUE_FAILED_DRIVER', 'database'), // <-- Set failed jobs driver
        'database' => env('DB_CONNECTION', 'mysql'),        // <-- Set failed jobs database
        'table' => 'failed_jobs',
    ],
];
```

```bash
#!/bin/bash
# scripts/queue-workers.sh

# Start multiple queue workers untuk load balancing
php artisan queue:work redis --queue=high-priority --sleep=1 --tries=3 --daemon &
php artisan queue:work redis --queue=notifications --sleep=3 --tries=3 --daemon &
php artisan queue:work redis --queue=default --sleep=5 --tries=3 --daemon &

# Monitor queue workers
php artisan queue:monitor high-priority,notifications,default --max=100
```

### Supervisor Configuration

```ini
; /etc/supervisor/conf.d/ictserve-queue.conf

[program:ictserve-high-priority]
process_name=%(program_name)s_%(process_num)02d
command=php /var/www/ictserve/artisan queue:work redis --queue=high-priority --sleep=1 --tries=3 --max-time=3600
directory=/var/www/ictserve
autostart=true
autorestart=true
stopasgroup=true
killasgroup=true
user=www-data
numprocs=2
redirect_stderr=true
stdout_logfile=/var/log/ictserve/queue-high-priority.log
stopwaitsecs=3600

[program:ictserve-notifications]
process_name=%(program_name)s_%(process_num)02d
command=php /var/www/ictserve/artisan queue:work redis --queue=notifications --sleep=3 --tries=3 --max-time=3600
directory=/var/www/ictserve
autostart=true
autorestart=true
stopasgroup=true
killasgroup=true
user=www-data
numprocs=4
redirect_stderr=true
stdout_logfile=/var/log/ictserve/queue-notifications.log
stopwaitsecs=3600

[group:ictserve-queues]
programs=ictserve-high-priority,ictserve-notifications
priority=999
```

### Queue Monitoring

```php
<?php
// app/Console/Commands/MonitorQueues.php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\Redis;
use Illuminate\Support\Facades\Log;

class MonitorQueues extends Command
{
    protected $signature = 'queue:monitor-health';
    protected $description = 'Monitor queue health and send alerts';

    public function handle()
    {
        $queues = ['high-priority', 'notifications', 'default'];
        $alerts = [];

        foreach ($queues as $queue) {
            $size = Redis::llen("queues:{$queue}");
            $threshold = $this->getThreshold($queue);

            if ($size > $threshold) {
                $alerts[] = [
                    'queue' => $queue,
                    'size' => $size,
                    'threshold' => $threshold,
                ];
            }

            $this->info("Queue {$queue}: {$size} jobs");
        }

        if (!empty($alerts)) {
            $this->sendAlert($alerts);
        }
    }

    protected function getThreshold(string $queue): int
    {
        return match($queue) {
            'high-priority' => 50,
            'notifications' => 200,
            'default' => 500,
        };
    }

    protected function sendAlert(array $alerts): void
    {
        Log::warning('Queue size threshold exceeded', $alerts);

        // Send notification to administrators
        // Implementation depends on your alerting system
    }
}
```

## Prestasi dan Pengoptimuman {#prestasi-dan-pengoptimuman}

### Caching Strategy

```php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Cache;
use App\Models\User;

class NotificationOptimizationService
{
    /**
     * Cache templat e-mel yang kerap digunakan
     */
    public function cacheEmailTemplate(string $template, array $data): string
    {
        $cacheKey = "email_template:{$template}:" . md5(serialize($data));

        return Cache::remember($cacheKey, 3600, function () use ($template, $data) {
            return view("emails.{$template}", $data)->render();
        });
    }

    /**
     * Cache user notification preferences
     */
    public function getCachedUserPreferences(int $userId): array
    {
        return Cache::remember("user_notification_prefs:{$userId}", 86400, function () use ($userId) {
            $user = User::find($userId);
            return $user ? $user->notification_preferences ?? [] : [];
        });
    }

    /**
     * Batch process notifications untuk efficiency
     */
    public function batchNotifications(array $notifications): void
    {
        collect($notifications)
            ->groupBy(function ($notification) {
                return get_class($notification['notification']);
            })
            ->each(function ($group, $notificationClass) {
                $this->processBatch($group, $notificationClass);
            });
    }

    /**
     * Process batch notifications
     */
    protected function processBatch($notifications, string $notificationClass): void
    {
        // Implement batch processing logic
        // Example: Send bulk emails using mail service API
    }
}
```

### Database Optimization

```php
<?php
// app/Jobs/OptimizeNotificationTables.php

namespace App\Jobs;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Support\Facades\DB;

class OptimizeNotificationTables implements ShouldQueue
{
    use Queueable;

    public function handle()
    {
        // Cleanup old notifications (older than 6 months)
        DB::table('notifications')
            ->where('created_at', '<', now()->subMonths(6))
            ->where('read_at', '!=', null)
            ->delete();

        // Cleanup old notification logs
        DB::table('activity_logs')
            ->where('event', 'notification.sent')
            ->where('created_at', '<', now()->subMonths(3))
            ->delete();

        // Optimize tables
        DB::statement('OPTIMIZE TABLE notifications');
        DB::statement('OPTIMIZE TABLE activity_logs');
    }
}
```

## Ujian dan Penyahpepijatan {#ujian-dan-penyahpepijatan}

### Unit Tests

```php
<?php
// tests/Unit/NotificationServiceTest.php

namespace Tests\Unit;

use Tests\TestCase;
use App\Services\NotificationService;
use App\Notifications\LoanApplicationApproved;
use App\Models\User;
use App\Models\LoanApplication;
use Illuminate\Support\Facades\Notification;
use Mockery;

class NotificationServiceTest extends TestCase
{
    protected $notificationService;
    protected $user;
    protected $loanApplication;

    protected function setUp(): void
    {
        parent::setUp();
        $this->notificationService = new NotificationService();
        $this->user = User::factory()->create();
        $this->loanApplication = LoanApplication::factory()->create();
    }

    /** @test */
    public function it_sends_notification_successfully()
    {
        Notification::fake();

        $notification = new LoanApplicationApproved($this->loanApplication);
        $this->notificationService->send($this->user, $notification);

        Notification::assertSentTo(
            $this->user,
            LoanApplicationApproved::class,
            function ($notification, $channels) {
                return in_array('mail', $channels) && in_array('database', $channels);
            }
        );
    }

    /** @test */
    public function it_respects_rate_limiting()
    {
        Notification::fake();

        // Set low rate limit for testing
        config(['notifications.rate_limit' => 2]);

        // Send notifications up to the limit
        for ($i = 0; $i < 3; $i++) {
            $notification = new LoanApplicationApproved($this->loanApplication);
            $this->notificationService->send($this->user, $notification);
        }

        // Only 2 notifications should be sent due to rate limiting
        Notification::assertSentToTimes($this->user, LoanApplicationApproved::class, 2);
    }

    /** @test */
    public function it_handles_notification_failures_gracefully()
    {
        // Mock notification to throw exception
        $notification = Mockery::mock(LoanApplicationApproved::class);
        $notification->shouldReceive('via')->andThrow(new \Exception('Email service down'));

        $this->notificationService->send($this->user, $notification);

        // Assert that error was logged (check logs or use Log::shouldReceive)
        $this->assertTrue(true); // Placeholder - implement proper assertion
    }
}
```

### Feature Tests

```php
<?php
// tests/Feature/NotificationFlowTest.php

namespace Tests\Feature;

use Tests\TestCase;
use App\Models\User;
use App\Models\LoanApplication;
use App\Notifications\LoanApplicationApproved;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Support\Facades\Notification;
use Illuminate\Support\Facades\Queue;

class NotificationFlowTest extends TestCase
{
    use RefreshDatabase;

    /** @test */
    public function loan_approval_triggers_notification()
    {
        Notification::fake();
        Queue::fake();

        $user = User::factory()->create();
        $approver = User::factory()->create();
        $application = LoanApplication::factory()->create(['user_id' => $user->id]);

        // Approve the application
        $this->actingAs($approver)
             ->patch(route('loan-applications.approve', $application))
             ->assertRedirect();

        // Assert notification was queued
        Queue::assertPushed(function ($job) use ($user) {
            return $job instanceof LoanApplicationApproved;
        });
    }

    /** @test */
    public function notification_email_contains_correct_content()
    {
        $user = User::factory()->create(['email' => 'test@motac.gov.my']);
        $application = LoanApplication::factory()->create();
        $notification = new LoanApplicationApproved($application);

        $mailMessage = $notification->toMail($user);

        $this->assertStringContains('Permohonan Pinjaman Diluluskan', $mailMessage->subject);
        $this->assertStringContains($application->application_number, $mailMessage->render());
    }
}
```

### Debugging Tools

```php
<?php
// app/Console/Commands/TestNotification.php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use App\Models\User;
use App\Notifications\TestNotification;

class TestNotificationCommand extends Command
{
    protected $signature = 'notification:test {user_id} {--type=email}';
    protected $description = 'Send test notification to user';

    public function handle()
    {
        $userId = $this->argument('user_id');
        $type = $this->option('type');

        $user = User::find($userId);
        if (!$user) {
            $this->error("User with ID {$userId} not found");
            return 1;
        }

        $notification = new TestNotification($type);

        try {
            $user->notify($notification);
            $this->info("Test notification sent to {$user->email}");
        } catch (\Exception $e) {
            $this->error("Failed to send notification: " . $e->getMessage());
            return 1;
        }

        return 0;
    }
}
```

## Pemantauan dan Metrik {#pemantauan-dan-metrik}

### Dashboard Metrik

```php
<?php
// app/Http/Controllers/Admin/NotificationMetricsController.php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;

class NotificationMetricsController extends Controller
{
    public function index()
    {
        $metrics = [
            'total_sent' => $this->getTotalSent(),
            'delivery_rate' => $this->getDeliveryRate(),
            'queue_stats' => $this->getQueueStats(),
            'failure_rate' => $this->getFailureRate(),
            'popular_notifications' => $this->getPopularNotifications(),
        ];

        return view('admin.notifications.metrics', compact('metrics'));
    }

    protected function getTotalSent(): int
    {
        return DB::table('activity_logs')
            ->where('event', 'notification.sent')
            ->whereDate('created_at', today())
            ->count();
    }

    protected function getDeliveryRate(): float
    {
        $sent = DB::table('activity_logs')
            ->where('event', 'notification.sent')
            ->whereDate('created_at', today())
            ->count();

        $failed = DB::table('failed_jobs')
            ->where('payload', 'like', '%notification%')
            ->whereDate('created_at', today())
            ->count();

        return $sent > 0 ? (($sent - $failed) / $sent) * 100 : 0;
    }

    protected function getQueueStats(): array
    {
        return [
            'high_priority' => Redis::llen('queues:high-priority'),
            'notifications' => Redis::llen('queues:notifications'),
            'default' => Redis::llen('queues:default'),
        ];
    }

    protected function getFailureRate(): float
    {
        $total = DB::table('activity_logs')
            ->where('event', 'like', 'notification.%')
            ->whereDate('created_at', today())
            ->count();

        $failed = DB::table('activity_logs')
            ->where('event', 'notification.failed')
            ->whereDate('created_at', today())
            ->count();

        return $total > 0 ? ($failed / $total) * 100 : 0;
    }

    protected function getPopularNotifications(): array
    {
        return DB::table('activity_logs')
            ->select('description', DB::raw('count(*) as count'))
            ->where('event', 'notification.sent')
            ->whereDate('created_at', '>=', today()->subDays(7))
            ->groupBy('description')
            ->orderByDesc('count')
            ->limit(10)
            ->get()
            ->toArray();
    }
}
```

### Real-time Monitoring

```php
<?php
// app/Events/NotificationSent.php

namespace App\Events;

use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class NotificationSent implements ShouldBroadcast
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public $notificationType;
    public $recipientCount;
    public $timestamp;

    public function __construct(string $notificationType, int $recipientCount)
    {
        $this->notificationType = $notificationType;
        $this->recipientCount = $recipientCount;
        $this->timestamp = now();
    }

    public function broadcastOn()
    {
        return new Channel('admin.notifications');
    }

    public function broadcastAs()
    {
        return 'notification.sent';
    }
}
```

## Pengendalian Ralat {#pengendalian-ralat}

### Custom Exception Handler

```php
<?php
// app/Exceptions/NotificationException.php

namespace App\Exceptions;

use Exception;
use Illuminate\Support\Facades\Log;

class NotificationException extends Exception
{
    protected $notificationData;
    protected $recipient;

    public function __construct(
        string $message,
        $recipient = null,
        array $notificationData = [],
        int $code = 0,
        Exception $previous = null
    ) {
        parent::__construct($message, $code, $previous);
        $this->recipient = $recipient;
        $this->notificationData = $notificationData;
    }

    public function report()
    {
        Log::error('Notification Error', [
            'message' => $this->getMessage(),
            'recipient' => $this->recipient?->email ?? 'Unknown',
            'notification_data' => $this->notificationData,
            'trace' => $this->getTraceAsString(),
        ]);
    }

    public function getRecipient()
    {
        return $this->recipient;
    }

    public function getNotificationData(): array
    {
        return $this->notificationData;
    }
}
```

### Retry Mechanism

```php
<?php
// app/Jobs/RetryFailedNotification.php

namespace App\Jobs;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;

class RetryFailedNotification implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    protected $notifiable;
    protected $notification;
    protected $attempt;

    public $tries = 3;
    public $backoff = [60, 300, 900]; // 1 min, 5 min, 15 min

    public function __construct($notifiable, $notification, int $attempt = 1)
    {
        $this->notifiable = $notifiable;
        $this->notification = $notification;
        $this->attempt = $attempt;
    }

    public function handle()
    {
        try {
            $this->notifiable->notify($this->notification);

            Log::info('Notification retry successful', [
                'attempt' => $this->attempt,
                'recipient' => $this->notifiable->email ?? 'Unknown',
                'notification' => get_class($this->notification),
            ]);

        } catch (\Exception $e) {
            Log::warning('Notification retry failed', [
                'attempt' => $this->attempt,
                'max_attempts' => $this->tries,
                'error' => $e->getMessage(),
            ]);

            if ($this->attempt < $this->tries) {
                // Schedule next retry
                RetryFailedNotification::dispatch(
                    $this->notifiable,
                    $this->notification,
                    $this->attempt + 1
                )->delay(now()->addSeconds($this->backoff[$this->attempt - 1]));
            } else {
                // Send to dead letter queue or alert admin
                $this->handleFinalFailure($e);
            }
        }
    }

    protected function handleFinalFailure(\Exception $e)
    {
        Log::error('Notification permanently failed', [
            'recipient' => $this->notifiable->email ?? 'Unknown',
            'notification' => get_class($this->notification),
            'final_error' => $e->getMessage(),
        ]);

        // Optionally notify administrators
        // AdminNotificationService::notifyOfPermanentFailure($this->notification, $e);
    }
}
```

## Keselamatan {#keselamatan}

### Input Sanitization

```php
<?php
// app/Services/NotificationSecurityService.php

namespace App\Services;

use Illuminate\Support\Str;
use Illuminate\Support\Facades\Validator;

class NotificationSecurityService
{
    /**
     * Sanitize notification content
     */
    public function sanitizeContent(array $data): array
    {
        return array_map(function ($value) {
            if (is_string($value)) {
                // Remove potentially harmful content
                $value = strip_tags($value);
                $value = htmlspecialchars($value, ENT_QUOTES, 'UTF-8');

                // Limit length to prevent abuse
                $value = Str::limit($value, 1000);
            }

            return $value;
        }, $data);
    }

    /**
     * Validate email addresses
     */
    public function validateEmailAddress(string $email): bool
    {
        $validator = Validator::make(['email' => $email], [
            'email' => 'required|email|max:255'
        ]);

        return !$validator->fails();
    }

    /**
     * Check for spam patterns
     */
    public function isSpam(string $content): bool
    {
        $spamPatterns = [
            '/\b(viagra|cialis|lottery|winner|congratulations)\b/i',
            '/\$\d+[,\d]*\.\d{2}/', // Money amounts
            '/https?:\/\/[^\s]+/i', // URLs
        ];

        foreach ($spamPatterns as $pattern) {
            if (preg_match($pattern, $content)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Rate limit per IP
     */
    public function isRateLimitedByIp(string $ip): bool
    {
        $key = "notification_rate_limit_ip:{$ip}";
        $attempts = cache()->get($key, 0);

        if ($attempts >= 10) { // Max 10 notifications per hour per IP
            return true;
        }

        cache()->put($key, $attempts + 1, 3600);
        return false;
    }
}
```

### Encryption for Sensitive Data

```php
<?php
// app/Notifications/SecureNotification.php

namespace App\Notifications;

use Illuminate\Notifications\Notification;
use Illuminate\Support\Facades\Crypt;

abstract class SecureNotification extends Notification
{
    /**
     * Encrypt sensitive data before storing
     */
    protected function encryptSensitiveData(array $data): array
    {
        $sensitiveFields = ['ic_number', 'phone_number', 'account_number'];

        foreach ($sensitiveFields as $field) {
            if (isset($data[$field])) {
                $data[$field] = Crypt::encryptString($data[$field]);
            }
        }

        return $data;
    }

    /**
     * Decrypt sensitive data when retrieving
     */
    protected function decryptSensitiveData(array $data): array
    {
        $sensitiveFields = ['ic_number', 'phone_number', 'account_number'];

        foreach ($sensitiveFields as $field) {
            if (isset($data[$field])) {
                try {
                    $data[$field] = Crypt::decryptString($data[$field]);
                } catch (\Exception $e) {
                    // Log decryption failure
                    Log::error("Failed to decrypt {$field}", ['error' => $e->getMessage()]);
                    $data[$field] = '[ENCRYPTED]';
                }
            }
        }

        return $data;
    }
}
```

## Panduan Penyelesaian Masalah {#panduan-penyelesaian-masalah}

### Isu Lazim dan Penyelesaian

| Isu                      | Simptom                     | Diagnosis                       | Penyelesaian                                           |
| ------------------------ | --------------------------- | ------------------------------- | ------------------------------------------------------ |
| **E-mel tidak dihantar** | Tiada e-mel diterima        | Semak queue status, SMTP config | `php artisan queue:restart` `php artisan config:cache` |
| **Notifikasi lewat**     | Delay lama dalam penerimaan | Queue backlog atau worker mati  | Tambah workers, monitor queue size                     |
| **E-mel berganda**       | Salinan berulang            | Job retry tanpa idempotency     | Implement unique job IDs                               |
| **Template error**       | E-mel kosong atau rosak     | Blade syntax error              | Check template syntax, test render                     |

| **Rate limiting** | Notifikasi tidak dihantar | Exceeded rate limits | Adjust limits atau implement batching |

### Diagnostic Commands

```bash
# Semak status queue
php artisan queue:monitor

# Lihat failed jobs
php artisan queue:failed

# Test mail configuration
php artisan tinker
>>> Mail::raw('Test email', function($msg) { $msg->to('test@example.com')->subject('Test'); });

# Semak notification dalam database
php artisan tinker
>>> App\Models\User::find(1)->notifications()->count();

# Monitor queue size
redis-cli llen "queues:notifications"

# Check worker processes
supervisorctl status ictserve-queues:*
```

### Logging dan Debug

```php
<?php
// config/logging.php - Add notification channel

'channels' => [
    // ... other channels

    'notifications' => [
        'driver' => 'daily',
        'path' => storage_path('logs/notifications.log'),
        'level' => env('LOG_LEVEL', 'debug'),
        'days' => 14,
    ],
],
```

### Health Check Endpoint

```php
<?php
// app/Http/Controllers/HealthCheckController.php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Redis;
use Illuminate\Support\Facades\DB;

class HealthCheckController extends Controller
{
    public function notifications()
    {
        try {
            $checks = [
                'database' => $this->checkDatabase(),
                'redis' => $this->checkRedis(),
                'mail' => $this->checkMailConfig(),
                'queues' => $this->checkQueues(),
            ];

            $allHealthy = collect($checks)->every(fn($check) => $check['healthy']);

            return response()->json([
                'status' => $allHealthy ? 'healthy' : 'unhealthy',
                'checks' => $checks,
                'timestamp' => now()->toISOString(),
            ], $allHealthy ? 200 : 503);

        } catch (\Exception $e) {
            return response()->json([
                'status' => 'error',
                'message' => $e->getMessage(),
                'timestamp' => now()->toISOString(),
            ], 500);
        }
    }

    protected function checkDatabase(): array
    {
        try {
            DB::table('notifications')->limit(1)->get();
            return ['healthy' => true, 'message' => 'Database connection OK'];
        } catch (\Exception $e) {
            return ['healthy' => false, 'message' => $e->getMessage()];
        }
    }

    protected function checkRedis(): array
    {
        try {
            Redis::ping();
            return ['healthy' => true, 'message' => 'Redis connection OK'];
        } catch (\Exception $e) {
            return ['healthy' => false, 'message' => $e->getMessage()];
        }
    }

    protected function checkMailConfig(): array
    {
        $config = config('mail');
        $required = ['default', 'from.address', 'from.name'];

        foreach ($required as $key) {
            if (empty(data_get($config, $key))) {
                return ['healthy' => false, 'message' => "Missing mail config: {$key}"];
            }
        }

        return ['healthy' => true, 'message' => 'Mail configuration OK'];
    }

    protected function checkQueues(): array
    {
        $queues = ['high-priority', 'notifications', 'default'];
        $queueStats = [];

        foreach ($queues as $queue) {
            $size = Redis::llen("queues:{$queue}");
            $queueStats[$queue] = $size;
        }

        $maxSize = max($queueStats);
        $healthy = $maxSize < 1000; // Threshold

        return [
            'healthy' => $healthy,
            'message' => $healthy ? 'Queue sizes normal' : 'Queue sizes exceed threshold',
            'stats' => $queueStats,
        ];
    }
}
```

## Best Practices {#best-practices}

### Performance Best Practices

1. **Queue Management**
    - Gunakan queue workers yang dedicated
    - Monitor queue sizes dan latency
    - Implement proper retry mechanisms
    - Use priority queues untuk notifikasi kritikal

2. **Template Optimization**
    - Cache templat yang kerap digunakan
    - Gunakan asset versioning
    - Minimize inline CSS
    - Optimize images dan attachments

3. **Database Optimization**
    - Index notification tables properly
    - Archive old notifications
    - Use read replicas untuk reporting
    - Implement proper pagination

4. **Caching Strategy**
    - Cache user preferences
    - Cache templat yang rendered
    - Use Redis untuk session storage
    - Implement cache warming

### Security Best Practices

1. **Input Validation**
    - Sanitize semua user inputs
    - Validate email addresses
    - Check untuk spam patterns
    - Implement rate limiting

2. **Data Protection**
    - Encrypt sensitive data
    - Use HTTPS untuk semua communications
    - Implement proper authentication
    - Log access dan changes

3. **Email Security**
    - Use SPF, DKIM, DMARC records
    - Implement proper SMTP authentication
    - Monitor untuk bounces dan complaints
    - Use dedicated IP addresses

### Monitoring Best Practices

1. **Metrics Collection**
    - Track delivery rates
    - Monitor queue depths
    - Measure response times
    - Alert on failures

2. **Logging Strategy**
    - Log semua notification events
    - Include contextual information
    - Use structured logging
    - Implement log retention policies

3. **Alerting Setup**
    - Alert pada high failure rates
    - Monitor queue backlogs
    - Track SLA violations
    - Implement escalation procedures

## Deployment Checklist

Gunakan senarai semak ini semasa menyebarkan sistem notifikasi ke staging atau production.

- [ ] Pastikan `.env` mengandungi pembolehubah `MAIL_*` dan `QUEUE_CONNECTION` yang betul.
- [ ] Pastikan `redis` dan `database` servis boleh dicapai dari aplikasi.
- [ ] Jalankan migrasi: `php artisan migrate --force`.
- [ ] Jalankan seeder yang diperlukan: `php artisan db:seed --class=NotificationSeeder` (jika ada).
- [ ] Konfigurasi Supervisor / systemd untuk autostart queue workers.
- [ ] Pastikan log rotation dan monitoring (Prometheus/CloudWatch) disiapkan.
- [ ] Uji penghantaran e-mel dengan akaun ujian dan semak bounces.

## Backup & Recovery

1. Backup database mengandungi jadual `notifications`, `failed_jobs`, dan `activity_logs` secara berkala (harian).
2. Simpan backup di lokasi yang selamat (off-site) untuk pemulihan bencana.
3. Untuk memulihkan notifikasi penting, import backup dan jalankan skrip verifikasi untuk konsistensi ID pada jadual berkaitan.

## Security References

Rujuk piawaian dan garis panduan berikut untuk memperkuatkan aspek keselamatan:

- [OWASP Top 10](https://owasp.org/www-project-top-ten/) â€” ringkasan ancaman web aplikasi
- NIST SP 800-53 untuk kawalan keselamatan (pilihan untuk kerajaan)
- RFC 7208 (SPF), RFC 6376 (DKIM), DMARC best practices untuk penghantaran e-mel yang selamat

## Maintenance & Alerting

- Sediakan alert untuk backlog queue melebihi ambang (contoh: notifications > 200).
- Sediakan alert untuk peningkatan kadar failed_jobs berkaitan notifikasi.
- Jadualkan tugas pembersihan untuk notifikasi lama (contoh: cron job `php artisan schedule:run`).

## Sejarah Revisi {#sejarah-revisi}

| Versi | Tarikh            | Pengarang        | Perubahan                                                                                                                               |
| ----- | ----------------- | ---------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| 2.1.0 | 26 September 2025 | Pasukan ICTServe | Tambah Panduan Pantas, Glosari, Diagram Urutan, Deployment Checklist, Backup & Recovery, Security References dan Maintenance & Alerting |
| 2.0   | 26 September 2025 | Pasukan ICTServe | Kemas kini komprehensif - tambah security, monitoring, troubleshooting                                                                  |
| 1.5   | 15 Ogos 2025      | Pasukan ICTServe | Tambah template management dan optimization                                                                                             |
| 1.0   | 12 Jun 2025       | Pasukan ICTServe | Versi awal dokumentasi                                                                                                                  |

## Sokongan dan Bantuan {#sokongan-dan-bantuan}

### Hubungan Teknikal

| Jenis Sokongan        | Hubungan                                                                        | Waktu Operasi | SLA    |
| --------------------- | ------------------------------------------------------------------------------- | ------------- | ------ |
| **Sokongan Sistem**   | [system-admin@ictserve.motac.gov.my](mailto:system-admin@ictserve.motac.gov.my) | 24/7          | 4 jam  |
| **Sokongan Aplikasi** | [support@ictserve.motac.gov.my](mailto:support@ictserve.motac.gov.my)           | 8AM-5PM       | 8 jam  |
| **Dokumentasi**       | [docs@ictserve.motac.gov.my](mailto:docs@ictserve.motac.gov.my)                 | 8AM-5PM       | 24 jam |

### Sumber Tambahan

- [Dokumentasi Laravel Notifications](https://laravel.com/docs/notifications)
- [Panduan Laravel Queues](https://laravel.com/docs/queues)
- [Best Practices Email Delivery](https://postmarkapp.com/guides)
- [SMTP Configuration Guide](https://laravel.com/docs/mail)

### Emergency Contacts

- **On-Call Engineer:** +60-12-345-6789
- **System Administrator:** +60-12-345-6790
- **DevOps Team:** [devops@motac.gov.my](mailto:devops@motac.gov.my)

---

## Ringkasan Penambahbaikan Utama

Dokumentasi sistem notifikasi e-mel ICTServe telah diperbaiki secara komprehensif dengan penambahbaikan berikut:

### 1. **Struktur dan Organisasi**

- Menambah metadata dokumen lengkap dengan sasaran audiens yang jelas
- Menyusun semula kandungan dengan hierarki logik dan navigasi yang mudah
- Sediakan kandungan yang komprehensif dari pengenalan hingga sokongan

### 2. **Implementasi Teknikal**

- Contoh kod PHP yang lengkap dan praktikal untuk semua komponen utama
- Implementasi Notification classes dengan best practices
- Service classes dengan error handling dan optimization
- Configuration examples yang realistik

### 3. **Keselamatan dan Kebolehpercayaan**

- Comprehensive security measures termasuk input sanitization
- Encryption untuk data sensitif
- Rate limiting dan spam protection
- Retry mechanisms dan error handling

### 4. **Pemantauan dan Diagnostik**

- Real-time monitoring dengan metrics dan dashboards
- Health check endpoints untuk system monitoring
- Comprehensive logging strategy
- Troubleshooting guide dengan diagnostic commands

### 5. **Performance dan Skalabiliti**

- Caching strategies untuk optimization
- Queue management dengan priority handling
- Database optimization techniques
- Batch processing untuk efficiency

### 6. **Testing dan Quality Assurance**

- Unit tests dan feature tests yang lengkap
- Debugging tools dan test commands
- Performance testing approaches
- Mock services untuk development

### 7. **Operasi dan Maintenance**

- Supervisor configuration untuk production
- Queue monitoring dan management
- Backup dan archival strategies
- Maintenance procedures dan schedules

Dokumentasi kini mematuhi standard industri untuk dokumentasi teknikal dan sesuai untuk digunakan oleh
pembangun sistem, pentadbir, dan jurutera DevOps.
